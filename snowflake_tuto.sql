--Choosing the database and the schema
use database SNOWFLAKE_SAMPLE_DATA;
use schema snowflake_sample_data.tpch_sf1;
--Choosing the warehouse
use warehouse COMPUTE_WH

--accessing the available tables
show tables;
--Consult some tables :
SELECT * FROM CUSTOMER LIMIT 10;
SELECT * FROM NATION;
SELECT * FROM REGION;
--Is it a foreign key ?
SELECT  C_NATIONKEY, COUNT(DISTINCT C_CUSTKEY)
FROM CUSTOMER 
GROUP BY C_NATIONKEY;

SELECT N_NATIONKEY, COUNT(C_CUSTKEY) 
FROM CUSTOMER_NATION   
GROUP BY N_NATIONKEY;

--Group By and Order By
SELECT C_MKTSEGMENT,COUNT(*) as cnt FROM  CUSTOMER GROUP BY C_MKTSEGMENT ORDER BY cnt DESC;
SELECT  c_nationkey,COUNT(*) as cnt FROM  CUSTOMER GROUP BY c_nationkey ORDER BY cnt DESC;

--time functions (equivalent datetime in python)
SELECT *  FROM ORDERS WHERE O_ORDERDATE >= DATEADD(day, -10,'1996-01-01') LIMIT 10;
SELECT DATEADD(month, -10,'1996-01-01');
SELECT DATEDIFF(day,'1996-01-01','1997-05-23' );
SELECT DATE_TRUNC(month,to_date('1997-05-23')  );
SELECT DATE_TRUNC(day,to_date('2015-10-06T11:54:00.000Z')  );


--error ! -> wrong type 
SELECT AVG(O_ORDERSTATUS) FROM ORDERS;

--CASE WHEN THEN WHEN THEN ELSE END = IF ELIF ELSE END 
SELECT O_ORDERPRIORITY, AVG(
    CASE WHEN O_ORDERSTATUS='F' THEN 0 
    ELSE  1 END ) AS BINARY_ORDERSTATUS
FROM ORDERS
GROUP BY O_ORDERPRIORITY
--HAVING BINARY_ORDERSTATUS  >= 0.486
;

--First Join (to get countries'info )  + Common Table Expression

WITH CUSTOMER_NATION AS (SELECT  C_CUSTKEY, C_MKTSEGMENT, C_NAME,N_NATIONKEY,N_NAME,N_REGIONKEY
FROM CUSTOMER
JOIN NATION ON CUSTOMER.C_NATIONKEY = NATION.N_NATIONKEY),

--Secound Join (regions' info)

CUSTOMER_REGION AS( SELECT  C_CUSTKEY, C_MKTSEGMENT, C_NAME,N_NATIONKEY,N_NAME,N_REGIONKEY, R_NAME
FROM CUSTOMER_NATION
JOIN REGION
ON CUSTOMER_NATION.N_REGIONKEY = REGION.R_REGIONKEY),

--Third Joinn (Orders)
CUSTOMER_ORDERS AS (SELECT  C_CUSTKEY, C_MKTSEGMENT, C_NAME,
        N_NATIONKEY,N_NAME,N_REGIONKEY, 
        R_NAME,
        O_ORDERKEY,O_TOTALPRICE, O_ORDERDATE
        FROM ORDERS
        JOIN CUSTOMER_REGION
        ON ORDERS.O_CUSTKEY = CUSTOMER_REGION.C_CUSTKEY),


-- Using ROW NUMBER(), PARTITION BY OVER : add columns with aggregated sum/means...

EXAMPLE_PARTITION_BY as (SELECT  N_NAME, 
        C_CUSTKEY, 
      -- ROW_NUMBER() OVER(PARTITION BY N_NAME
       --ORDER BY O_TOTALPRICE DESC) AS "Row Number", 
       O_TOTALPRICE, 
       COUNT( O_ORDERKEY) OVER(PARTITION BY N_NAME) AS CountOfOrders, 
       AVG(O_TOTALPRICE) OVER(PARTITION BY N_NAME) AS AvgOrderAmount, 
       MIN(O_TOTALPRICE) OVER(PARTITION BY N_NAME) AS MinOrderAmount, 
       SUM(O_TOTALPRICE) OVER(PARTITION BY N_NAME) TotalOrderAmount
FROM CUSTOMER_ORDERS),

--Comment the following lines if you wish to use  EXAMPLE_CUMUL_SUM            
--Notice the difference with a simple GROUP BY :
SELECT N_NAME , SUM(O_TOTALPRICE) as PRICE
FROM CUSTOMER_ORDERS
GROUP BY N_NAME;

EXAMPLE_CUMUL_SUM AS (SELECT  N_NAME, 
        C_CUSTKEY,  
       O_TOTALPRICE,  
       ROW_NUMBER() OVER(PARTITION BY N_NATIONKEY
       ORDER BY O_TOTALPRICE DESC) AS "Row Number", 
       COUNT( O_ORDERKEY) OVER(PARTITION BY N_NATIONKEY) AS CountOfOrders,
       --Equivalent of cumsum() in pandas : 
       (SUM(O_TOTALPRICE) OVER(PARTITION BY  N_NATIONKEY
       ORDER BY O_TOTALPRICE DESC ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)) AS CumulativeTotal
       FROM CUSTOMER_ORDERS
       --ORDER BY N_NAME, "Row Number"
       )

SELECT * FROM  EX_CUMUL_SUM WHERE "Row Number" =1 ;